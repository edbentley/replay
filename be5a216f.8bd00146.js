(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{127:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return u}));var a=n(3),r=n(7),i=(n(0),n(159)),l=n(167),p=n(168),o={id:"mutable-sprites",title:"Mutable Sprites"},s={unversionedId:"mutable-sprites",id:"mutable-sprites",isDocsHomePage:!1,title:"Mutable Sprites",description:"Intro",source:"@site/docs/mutable-sprites.md",slug:"/mutable-sprites",permalink:"/docs/mutable-sprites",editUrl:"https://github.com/edbentley/replay/edit/master/website/docs/mutable-sprites.md",version:"current",sidebar:"someSidebar",previous:{title:"Pure Sprites",permalink:"/docs/pure-sprites"},next:{title:"Replay Test",permalink:"/docs/test"}},c=[{value:"Intro",id:"intro",children:[]},{value:"API",id:"api",children:[{value:"MySprite.Single(props, update)",id:"myspritesingleprops-update",children:[]},{value:"MySprite.Array({ props, array, key, update, updateAll, filter })",id:"myspritearray-props-array-key-update-updateall-filter-",children:[]},{value:"t2.text(props, update)",id:"t2textprops-update",children:[]},{value:"t2.textArray({ props, array, update, mask, testId })",id:"t2textarray-props-array-update-mask-testid-",children:[]},{value:"t2.circle(props, update)",id:"t2circleprops-update",children:[]},{value:"t2.circleArray({ props, array, update, mask, testId })",id:"t2circlearray-props-array-update-mask-testid-",children:[]},{value:"t2.rectangle(props, update)",id:"t2rectangleprops-update",children:[]},{value:"t2.rectangleArray({ props, array, update, mask, testId })",id:"t2rectanglearray-props-array-update-mask-testid-",children:[]},{value:"t2.line(props, update)",id:"t2lineprops-update",children:[]},{value:"t2.lineArray({ props, array, update, mask, testId })",id:"t2linearray-props-array-update-mask-testid-",children:[]},{value:"t2.image(props, update)",id:"t2imageprops-update",children:[]},{value:"t2.imageArray({ props, array, update, mask, testId })",id:"t2imagearray-props-array-update-mask-testid-",children:[]},{value:"t2.spriteSheet(props, update)",id:"t2spritesheetprops-update",children:[]},{value:"r.if(condition, sprites)",id:"rifcondition-sprites",children:[]},{value:"r.ifElse(condition, trueSprites, falseSprites)",id:"rifelsecondition-truesprites-falsesprites",children:[]},{value:"r.onChange(value, sprites)",id:"ronchangevalue-sprites",children:[]},{value:"r.run(fn)",id:"rrunfn",children:[]}]},{value:"Example",id:"example",children:[]},{value:"Context",id:"context",children:[]},{value:"Native Sprites",id:"native-sprites",children:[]}],b={toc:c};function u(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"intro"},"Intro"),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"Mutable Sprites")," are an alternative API for Sprites and Textures which drastically reduce the amount of Garbage Collection (GC) required by the JavaScript engine. This can result in big performance improvements, especially in dropped frames due to regular GC. To do this they rely on mutating state and props instead of always returning new objects."),Object(i.b)("p",null,"A Custom Sprite may contain a Mutable Sprite, but not vice versa. The ",Object(i.b)("a",{parentName:"p",href:"/docs/top-level-game"},"Top-Level Game")," Sprite also cannot be Mutable."),Object(i.b)("p",null,"You can create a Mutable Sprite with the ",Object(i.b)("inlineCode",{parentName:"p"},"makeMutableSprite")," function, which is similar to a ",Object(i.b)("a",{parentName:"p",href:"/docs/sprites"},"Sprite")," but with a few differences:"),Object(i.b)(l.a,{defaultValue:"js",groupId:"code",values:[{label:"JavaScript",value:"js"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},Object(i.b)(p.a,{value:"js",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},'import { makeMutableSprite, t2 } from "@replay/core";\nimport { Player } from "./player";\n\nexport const Level = makeMutableSprite({\n  init() {\n    return { playerX: 0 };\n  },\n\n  loop({ state }) {\n    state.playerX++;\n  },\n\n  render({ state }) {\n    return [\n      t2.circle(\n        {\n          radius: 20,\n          color: "purple",\n        },\n        (thisProps) => {\n          thisProps.x = state.playerX;\n        }\n      ),\n      Player.Single(\n        {\n          rotation: 10,\n          color: "red",\n        },\n        (thisProps) => {\n          thisProps.x = state.playerX;\n        }\n      ),\n    ];\n  },\n});\n'))),Object(i.b)(p.a,{value:"ts",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},'import { makeMutableSprite, t2 } from "@replay/core";\nimport { WebInputs } from "@replay/web";\nimport { iOSInputs } from "@replay/swift";\nimport { Player } from "./player";\n\ntype Props = {};\ntype State = {\n  playerX: number;\n};\n\nexport const Level = makeMutableSprite<Props, State, WebInputs | iOSInputs>({\n  init() {\n    return { playerX: 0 };\n  },\n\n  loop({ state }) {\n    state.playerX++;\n  },\n\n  render({ state }) {\n    return [\n      t2.circle(\n        {\n          radius: 20,\n          color: "purple",\n        },\n        (thisProps) => {\n          thisProps.x = state.playerX;\n        }\n      ),\n      Player.Single(\n        {\n          rotation: 10,\n          color: "red",\n        },\n        (thisProps) => {\n          thisProps.x = state.playerX;\n        }\n      ),\n    ];\n  },\n});\n')))),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"loop")," method of the ",Object(i.b)("inlineCode",{parentName:"p"},"Level")," Mutable Sprite no longer needs to return a new state, instead you can mutate the ",Object(i.b)("inlineCode",{parentName:"p"},"state")," object directly."),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"render")," function is returning a ",Object(i.b)("inlineCode",{parentName:"p"},"circle")," Mutable Texture and a single ",Object(i.b)("inlineCode",{parentName:"p"},"Player")," Mutable Sprite. Use ",Object(i.b)("inlineCode",{parentName:"p"},"t2")," instead of ",Object(i.b)("inlineCode",{parentName:"p"},"t")," for Mutable Textures. Instead of taking a single props argument, the 1st argument is the initial props, and the 2nd argument is an update callback which is run every frame. ",Object(i.b)("inlineCode",{parentName:"p"},"thisProps")," can be mutated to update the props being passed to ",Object(i.b)("inlineCode",{parentName:"p"},"circle")," or ",Object(i.b)("inlineCode",{parentName:"p"},"Player"),"."),Object(i.b)("div",{className:"admonition admonition-tip alert alert--success"},Object(i.b)("div",{parentName:"div",className:"admonition-heading"},Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",{parentName:"h5",className:"admonition-icon"},Object(i.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},Object(i.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Important")),Object(i.b)("div",{parentName:"div",className:"admonition-content"},Object(i.b)("p",{parentName:"div"},"The ",Object(i.b)("inlineCode",{parentName:"p"},"render")," function is only called once after ",Object(i.b)("inlineCode",{parentName:"p"},"init"),". All updates are applied through update callbacks like the 2nd argument of ",Object(i.b)("inlineCode",{parentName:"p"},"Player.Single"),"."))),Object(i.b)("p",null,"To call a Mutable Sprite from a Custom Sprite, make sure an ",Object(i.b)("inlineCode",{parentName:"p"},"id")," prop is passed in (they're not required within Mutable Sprites):"),Object(i.b)(l.a,{defaultValue:"js",groupId:"code",values:[{label:"JavaScript",value:"js"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},Object(i.b)(p.a,{value:"js",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},'import { makeSprite } from "@replay/core";\nimport { Item } from "./item";\n\nexport const Player = makeSprite({\n  render({ props }) {\n    return [\n      Item.Single({\n        id: "Item",\n        item: props.item,\n      }),\n    ];\n  },\n});\n'))),Object(i.b)(p.a,{value:"ts",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},'import { makeSprite } from "@replay/core";\nimport { Item } from "./item";\n\ntype Props = {\n  item: string;\n};\nexport const Player = makeSprite<Props>({\n  render({ props }) {\n    return [\n      Item.Single({\n        id: "Item",\n        item: props.item,\n      }),\n    ];\n  },\n});\n')),Object(i.b)("p",null,"The 2nd argument of ",Object(i.b)("inlineCode",{parentName:"p"},"Item.Single")," (the update callback) won't be used since ",Object(i.b)("inlineCode",{parentName:"p"},"render")," will run every frame in the ",Object(i.b)("inlineCode",{parentName:"p"},"Player")," Custom Sprite. To reduce GC it's best to avoid this as much as possible by nesting multiple Mutable Sprites within one Mutable Sprite."))),Object(i.b)("h2",{id:"api"},"API"),Object(i.b)("h3",{id:"myspritesingleprops-update"},"MySprite.Single(props, update)"),Object(i.b)("p",null,"Render a single Mutable Sprite."),Object(i.b)("h4",{id:"arguments"},"Arguments"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"props"),": The initial props for the Sprite."),Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"update(thisProps)"),": (Optional) Callback to mutate the Sprite's props.")),Object(i.b)("h3",{id:"myspritearray-props-array-key-update-updateall-filter-"},"MySprite.Array({ props, array, key, update, updateAll, filter })"),Object(i.b)("p",null,"Render an array of Mutable Sprites."),Object(i.b)("h4",{id:"arguments-1"},"Arguments"),Object(i.b)("p",null,"An object with the following properties:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"props(itemState, index)"),": A function returning Sprite's props. This is called for each new element in the array with the element's value ",Object(i.b)("inlineCode",{parentName:"li"},"itemState")," and its position in the array ",Object(i.b)("inlineCode",{parentName:"li"},"index"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"array()"),": A function returning the array data to render."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"key(itemState, index)"),": (Optional) A function returning a unique (within the array) id ",Object(i.b)("inlineCode",{parentName:"li"},"string")," or ",Object(i.b)("inlineCode",{parentName:"li"},"number"),". You can just return ",Object(i.b)("inlineCode",{parentName:"li"},"index")," to avoid creating strings every frame if you don't need to preserve state."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"update(thisProps, itemState, index)"),": (Optional) Callback to mutate the Sprite's props."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"updateAll(thisProps)"),": (Optional) Callback to mutate props for all Sprites in the array. This can avoid repeated calculations for every Sprite."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"filter(itemState, index)"),": (Optional) A function returning whether to render an element (",Object(i.b)("inlineCode",{parentName:"li"},"true"),") or not (",Object(i.b)("inlineCode",{parentName:"li"},"false"),").")),Object(i.b)("h3",{id:"t2textprops-update"},"t2.text(props, update)"),Object(i.b)("h4",{id:"arguments-2"},"Arguments"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"props"),": Partial of text ",Object(i.b)("a",{parentName:"li",href:"/docs/textures#text"},"Texture")," props."),Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"update(thisProps)"),": (Optional) Callback to mutate the texture's props.")),Object(i.b)("h3",{id:"t2textarray-props-array-update-mask-testid-"},"t2.textArray({ props, array, update, mask, testId })"),Object(i.b)("h4",{id:"arguments-3"},"Arguments"),Object(i.b)("p",null,"An object with the following properties:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"props(itemState, index)"),": A function returning partial of text ",Object(i.b)("a",{parentName:"li",href:"/docs/textures#text"},"Texture")," props. This is called for each new element in the array with the element's value ",Object(i.b)("inlineCode",{parentName:"li"},"itemState")," and its position in the array ",Object(i.b)("inlineCode",{parentName:"li"},"index"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"array()"),": A function returning the array data to render."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"update(thisProps, itemState, index)"),": (Optional) Callback to mutate the texture's props."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"mask"),": (Optional) A ",Object(i.b)("a",{parentName:"li",href:"/docs/mask"},"Mask")," for all elements."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"testId(itemState, index)"),": (Optional) A function returning a unique test id string, used by ",Object(i.b)("a",{parentName:"li",href:"/docs/test"},"Replay Test"),".")),Object(i.b)("h3",{id:"t2circleprops-update"},"t2.circle(props, update)"),Object(i.b)("h4",{id:"arguments-4"},"Arguments"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"props"),": Partial of circle ",Object(i.b)("a",{parentName:"li",href:"/docs/textures#circle"},"Texture")," props."),Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"update(thisProps)"),": (Optional) Callback to mutate the texture's props.")),Object(i.b)("h3",{id:"t2circlearray-props-array-update-mask-testid-"},"t2.circleArray({ props, array, update, mask, testId })"),Object(i.b)("h4",{id:"arguments-5"},"Arguments"),Object(i.b)("p",null,"An object with the following properties:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"props(itemState, index)"),": A function returning partial of circle ",Object(i.b)("a",{parentName:"li",href:"/docs/textures#circle"},"Texture")," props. This is called for each new element in the array with the element's value ",Object(i.b)("inlineCode",{parentName:"li"},"itemState")," and its position in the array ",Object(i.b)("inlineCode",{parentName:"li"},"index"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"array()"),": A function returning the array data to render."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"update(thisProps, itemState, index)"),": (Optional) Callback to mutate the texture's props."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"mask"),": (Optional) A ",Object(i.b)("a",{parentName:"li",href:"/docs/mask"},"Mask")," for all elements."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"testId(itemState, index)"),": (Optional) A function returning a unique test id string, used by ",Object(i.b)("a",{parentName:"li",href:"/docs/test"},"Replay Test"),".")),Object(i.b)("h3",{id:"t2rectangleprops-update"},"t2.rectangle(props, update)"),Object(i.b)("h4",{id:"arguments-6"},"Arguments"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"props"),": Partial of rectangle ",Object(i.b)("a",{parentName:"li",href:"/docs/textures#rectangle"},"Texture")," props."),Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"update(thisProps)"),": (Optional) Callback to mutate the texture's props.")),Object(i.b)("h3",{id:"t2rectanglearray-props-array-update-mask-testid-"},"t2.rectangleArray({ props, array, update, mask, testId })"),Object(i.b)("h4",{id:"arguments-7"},"Arguments"),Object(i.b)("p",null,"An object with the following properties:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"props(itemState, index)"),": A function returning partial of rectangle array ",Object(i.b)("a",{parentName:"li",href:"/docs/textures#rectangle-array"},"Texture")," props. This is called for each new element in the array with the element's value ",Object(i.b)("inlineCode",{parentName:"li"},"itemState")," and its position in the array ",Object(i.b)("inlineCode",{parentName:"li"},"index"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"array()"),": A function returning the array data to render."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"update(thisProps, itemState, index)"),": (Optional) Callback to mutate the texture's props."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"mask"),": (Optional) A ",Object(i.b)("a",{parentName:"li",href:"/docs/mask"},"Mask")," for all elements."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"testId(itemState, index)"),": (Optional) A function returning a unique test id string, used by ",Object(i.b)("a",{parentName:"li",href:"/docs/test"},"Replay Test"),".")),Object(i.b)("h3",{id:"t2lineprops-update"},"t2.line(props, update)"),Object(i.b)("h4",{id:"arguments-8"},"Arguments"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"props"),": Partial of line ",Object(i.b)("a",{parentName:"li",href:"/docs/textures#line"},"Texture")," props."),Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"update(thisProps)"),": (Optional) Callback to mutate the texture's props.")),Object(i.b)("h3",{id:"t2linearray-props-array-update-mask-testid-"},"t2.lineArray({ props, array, update, mask, testId })"),Object(i.b)("h4",{id:"arguments-9"},"Arguments"),Object(i.b)("p",null,"An object with the following properties:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"props(itemState, index)"),": A function returning partial of line ",Object(i.b)("a",{parentName:"li",href:"/docs/textures#line"},"Texture")," props. This is called for each new element in the array with the element's value ",Object(i.b)("inlineCode",{parentName:"li"},"itemState")," and its position in the array ",Object(i.b)("inlineCode",{parentName:"li"},"index"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"array()"),": A function returning the array data to render."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"update(thisProps, itemState, index)"),": (Optional) Callback to mutate the texture's props."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"mask"),": (Optional) A ",Object(i.b)("a",{parentName:"li",href:"/docs/mask"},"Mask")," for all elements."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"testId(itemState, index)"),": (Optional) A function returning a unique test id string, used by ",Object(i.b)("a",{parentName:"li",href:"/docs/test"},"Replay Test"),".")),Object(i.b)("h3",{id:"t2imageprops-update"},"t2.image(props, update)"),Object(i.b)("h4",{id:"arguments-10"},"Arguments"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"props"),": Partial of image ",Object(i.b)("a",{parentName:"li",href:"/docs/textures#image"},"Texture")," props."),Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"update(thisProps)"),": (Optional) Callback to mutate the texture's props.")),Object(i.b)("h3",{id:"t2imagearray-props-array-update-mask-testid-"},"t2.imageArray({ props, array, update, mask, testId })"),Object(i.b)("h4",{id:"arguments-11"},"Arguments"),Object(i.b)("p",null,"An object with the following properties:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"props(itemState, index)"),": A function returning partial of image array ",Object(i.b)("a",{parentName:"li",href:"/docs/textures#image-array"},"Texture")," props. This is called for each new element in the array with the element's value ",Object(i.b)("inlineCode",{parentName:"li"},"itemState")," and its position in the array ",Object(i.b)("inlineCode",{parentName:"li"},"index"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"array()"),": A function returning the array data to render."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"update(thisProps, itemState, index)"),": (Optional) Callback to mutate the texture's props."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"mask"),": (Optional) A ",Object(i.b)("a",{parentName:"li",href:"/docs/mask"},"Mask")," for all elements."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"testId(itemState, index)"),": (Optional) A function returning a unique test id string, used by ",Object(i.b)("a",{parentName:"li",href:"/docs/test"},"Replay Test"),".")),Object(i.b)("h3",{id:"t2spritesheetprops-update"},"t2.spriteSheet(props, update)"),Object(i.b)("h4",{id:"arguments-12"},"Arguments"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"props"),": Partial of sprite sheet ",Object(i.b)("a",{parentName:"li",href:"/docs/textures#sprite-sheet"},"Texture")," props."),Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"update(thisProps)"),": (Optional) Callback to mutate the texture's props.")),Object(i.b)("h3",{id:"rifcondition-sprites"},"r.if(condition, sprites)"),Object(i.b)("h4",{id:"arguments-13"},"Arguments"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"condition()"),": A function that returns a ",Object(i.b)("inlineCode",{parentName:"li"},"boolean"),"."),Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"sprites()"),": A function returning an array of Mutable Sprites to render only if the 1st argument returns ",Object(i.b)("inlineCode",{parentName:"li"},"true"),".")),Object(i.b)("h3",{id:"rifelsecondition-truesprites-falsesprites"},"r.ifElse(condition, trueSprites, falseSprites)"),Object(i.b)("h4",{id:"arguments-14"},"Arguments"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"condition()"),": A function that returns a ",Object(i.b)("inlineCode",{parentName:"li"},"boolean"),"."),Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"trueSprites()"),": A function returning an array of Mutable Sprites to render only if the 1st argument returns ",Object(i.b)("inlineCode",{parentName:"li"},"true"),"."),Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"falseSprites()"),": A function returning an array of Mutable Sprites to render only if the 1st argument returns ",Object(i.b)("inlineCode",{parentName:"li"},"false"),".")),Object(i.b)("h3",{id:"ronchangevalue-sprites"},"r.onChange(value, sprites)"),Object(i.b)("h4",{id:"arguments-15"},"Arguments"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"value()"),": A function that returns a value to watch."),Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"sprites()"),": A function returning an array of Mutable Sprites. This will re-render whenever the ",Object(i.b)("inlineCode",{parentName:"li"},"value")," returned changes (",Object(i.b)("inlineCode",{parentName:"li"},"prev !== new"),"). (This will cause Sprites to unmount and remount, which will reset their state.)")),Object(i.b)("h3",{id:"rrunfn"},"r.run(fn)"),Object(i.b)("h4",{id:"arguments-16"},"Arguments"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("inlineCode",{parentName:"li"},"fn()"),": A function that runs every frame.")),Object(i.b)("h2",{id:"example"},"Example"),Object(i.b)(l.a,{defaultValue:"js",groupId:"code",values:[{label:"JavaScript",value:"js"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},Object(i.b)(p.a,{value:"js",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},'import { t2, r, makeMutableSprite } from "@replay/core";\n\nexport const MyMutSprite = makeMutableSprite({\n  init() {\n    return {\n      score: 0,\n      enemies: [\n        { x: 40, y: 0, id: "1" },\n        { x: 10, y: 20, id: "2" },\n      ],\n    };\n  },\n\n  loop({ state }) {\n    // Mutate state directly here, no need to return it\n\n    if (state.score < 100) {\n      state.score++;\n    }\n\n    if (state.score === 50) {\n      state.enemies.unshift({ x: -50, y: 0, id: "3" });\n    }\n\n    let indexToRemove = -1;\n    state.enemies.forEach((enemy, index) => {\n      enemy.x++;\n      if (enemy.x > 75) {\n        indexToRemove = index;\n      }\n    });\n\n    if (indexToRemove >= 0) {\n      state.enemies.splice(indexToRemove, 1);\n    }\n  },\n\n  render({ state, props }) {\n    // This function is only called once\n    return [\n      // Use t2 instead of t\n      t2.text(\n        // First parameter is the initial props (which don\'t need to update)\n        { color: "black", y: 25 },\n        // Second parameter is the update function which is called every frame.\n        // Use this to update the text Texture\'s props (thisProps).\n        (thisProps) => {\n          thisProps.text = `Score: ${state.score}`;\n        }\n      ),\n\n      // A Mutable Sprite util to change the Sprites rendered.\n      r.if(\n        // This will be called every frame\n        () => state.score > props.highScore,\n        // This will only be called when the return value of the first argument changes.\n        () => [t2.text({ text: "High score!", color: "black", x: -100 })]\n      ),\n\n      t2.circle({ radius: 3, color: "red" }, (thisProps) => {\n        thisProps.x++;\n      }),\n\n      // To render an array of Textures linked to an array\n      t2.rectangleArray({\n        // The default props\n        props: (itemState, index) => ({\n          width: 50,\n          height: 50,\n          color: "red",\n        }),\n        update: (thisProps) => {\n          thisProps.x++;\n        },\n        // The array to link to. Element values will be `itemState` in other functions\n        array: () => lengthFiveArray,\n        // Set a test id for rectangles in an array\n        testId: (itemState, index) => `Rect${index}`,\n      }),\n\n      // Use MyMutNestedSprite.Single(...) instead of calling MyMutNestedSprite(...)\n      MyMutNestedSprite.Single(\n        // Initial props which won\'t update\n        { index: -1 }\n      ),\n\n      MyMutNestedSprite.Single(\n        { index: 20, y: -20 },\n        // Update function to update MyMutNestedSprite\'s props (thisProps)\n        (thisProps) => {\n          if (thisProps.index > -100) {\n            thisProps.index--;\n          }\n        }\n      ),\n\n      // Use .Array to render an array of Sprites, linked to an array.\n      MyMutNestedSprite.Array({\n        // The default props\n        props: (itemState, index) => ({ index: -1 }),\n        update: (thisProps, itemState, index) => {\n          thisProps.index = index;\n          thisProps.y = index * 30 + 50;\n        },\n        // The array to link to. Element values will be `itemState` in other functions\n        array: () => lengthFiveArray,\n        // Need a unique key\n        key: (_, index) => index,\n      }),\n\n      Enemy.Array({\n        props: () => ({}),\n        update: (thisProps, itemState) => {\n          thisProps.x = itemState.x;\n          thisProps.y = itemState.y;\n        },\n        array: () => state.enemies,\n        key: (enemy) => enemy.id,\n      }),\n    ];\n  },\n});\n'))),Object(i.b)(p.a,{value:"ts",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},'import { t2, r, makeMutableSprite } from "@replay/core";\n\ntype Props = {\n  highScore: number;\n};\ntype State = {\n  score: number;\n  enemies: { x: number; y: number; id: string }[];\n};\n\nexport const MyMutSprite = makeMutableSprite<Props, State>({\n  init() {\n    return {\n      score: 0,\n      enemies: [\n        { x: 40, y: 0, id: "1" },\n        { x: 10, y: 20, id: "2" },\n      ],\n    };\n  },\n\n  loop({ state }) {\n    // Mutate state directly here, no need to return it\n\n    if (state.score < 100) {\n      state.score++;\n    }\n\n    if (state.score === 50) {\n      state.enemies.unshift({ x: -50, y: 0, id: "3" });\n    }\n\n    let indexToRemove = -1;\n    state.enemies.forEach((enemy, index) => {\n      enemy.x++;\n      if (enemy.x > 75) {\n        indexToRemove = index;\n      }\n    });\n\n    if (indexToRemove >= 0) {\n      state.enemies.splice(indexToRemove, 1);\n    }\n  },\n\n  render({ state, props }) {\n    // This function is only called once\n    return [\n      // Use t2 instead of t\n      t2.text(\n        // First parameter is the initial props (which don\'t need to update)\n        { color: "black", y: 25 },\n        // Second parameter is the update function which is called every frame.\n        // Use this to update the text Texture\'s props (thisProps).\n        (thisProps) => {\n          thisProps.text = `Score: ${state.score}`;\n        }\n      ),\n\n      // A Mutable Sprite util to change the Sprites rendered.\n      r.if(\n        // This will be called every frame\n        () => state.score > props.highScore,\n        // This will only be called when the return value of the first argument changes.\n        () => [t2.text({ text: "High score!", color: "black", x: -100 })]\n      ),\n\n      t2.circle({ radius: 3, color: "red" }, (thisProps) => {\n        thisProps.x++;\n      }),\n\n      // To render an array of Textures linked to an array\n      t2.rectangleArray({\n        // The default props\n        props: (itemState, index) => ({\n          width: 50,\n          height: 50,\n          color: "red",\n        }),\n        update: (thisProps) => {\n          thisProps.x++;\n        },\n        // The array to link to. Element values will be `itemState` in other functions\n        array: () => lengthFiveArray,\n        // Set a test id for rectangles in an array\n        testId: (itemState, index) => `Rect${index}`,\n      }),\n\n      // Use MyMutNestedSprite.Single(...) instead of calling MyMutNestedSprite(...)\n      MyMutNestedSprite.Single(\n        // Initial props which won\'t update\n        { index: -1 }\n      ),\n\n      MyMutNestedSprite.Single(\n        { index: 20, y: -20 },\n        // Update function to update MyMutNestedSprite\'s props (thisProps)\n        (thisProps) => {\n          if (thisProps.index > -100) {\n            thisProps.index--;\n          }\n        }\n      ),\n\n      // Use .Array to render an array of Sprites, linked to an array.\n      MyMutNestedSprite.Array({\n        // The default props\n        props: (itemState, index) => ({ index: -1 }),\n        update: (thisProps, itemState, index) => {\n          thisProps.index = index;\n          thisProps.y = index * 30 + 50;\n        },\n        // The array to link to. Element values will be `itemState` in other functions\n        array: () => lengthFiveArray,\n        // Need a unique key\n        key: (_, index) => index,\n      }),\n\n      Enemy.Array({\n        props: () => ({}),\n        update: (thisProps, itemState) => {\n          thisProps.x = itemState.x;\n          thisProps.y = itemState.y;\n        },\n        array: () => state.enemies,\n        key: (enemy) => enemy.id,\n      }),\n    ];\n  },\n});\n')))),Object(i.b)("h2",{id:"context"},"Context"),Object(i.b)("p",null,"A Mutable Sprite cannot use a ",Object(i.b)("a",{parentName:"p",href:"/docs/context"},"Context")," from a non-Mutable Sprite. Create a Context in the normal way but use ",Object(i.b)("inlineCode",{parentName:"p"},"context.Single"),". The ",Object(i.b)("inlineCode",{parentName:"p"},"context")," prop is a function which is updated every frame to avoid stale values."),Object(i.b)(l.a,{defaultValue:"js",groupId:"code",values:[{label:"JavaScript",value:"js"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},Object(i.b)(p.a,{value:"js",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},'import { makeMutableSprite } from "@replay/core";\n\nconst ThemeSprite = makeMutableSprite({\n  render({ props }) {\n    return [\n      themeContext.Single({\n        context: () => props.theme,\n        sprites: [Button.Single({})],\n      }),\n    ];\n  },\n});\n'))),Object(i.b)(p.a,{value:"ts",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},'import { makeMutableSprite } from "@replay/core";\n\nconst ThemeSprite = makeMutableSprite<{ theme: string }>({\n  render({ props }) {\n    return [\n      themeContext.Single({\n        context: () => props.theme,\n        sprites: [Button.Single({})],\n      }),\n    ];\n  },\n});\n')))),Object(i.b)("p",null,"Be aware that values returned with ",Object(i.b)("inlineCode",{parentName:"p"},"getContext")," may not update unless they're mutated, so it can be worth calling ",Object(i.b)("inlineCode",{parentName:"p"},"getContext")," in your update callbacks rather than in the body of ",Object(i.b)("inlineCode",{parentName:"p"},"render"),"."),Object(i.b)("h2",{id:"native-sprites"},"Native Sprites"),Object(i.b)("p",null,"Native Sprites also have an optional 2nd argument, which is used when nested in Mutable Sprites to update their props:"),Object(i.b)(l.a,{defaultValue:"js",groupId:"code",values:[{label:"JavaScript",value:"js"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},Object(i.b)(p.a,{value:"js",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},'import { makeMutableSprite } from "@replay/core";\nimport { MyWidget } from "./widget";\n\nconst MySprite = makeMutableSprite({\n  render({ props }) {\n    return [\n      MyWidget(\n        {\n          id: "MyWidget",\n          score: props.score,\n        },\n        (thisProps) => {\n          thisProps.score = props.score;\n        }\n      ),\n    ];\n  },\n});\n'))),Object(i.b)(p.a,{value:"ts",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},'import { makeMutableSprite } from "@replay/core";\nimport { MyWidget } from "./widget";\n\nconst MySprite = makeMutableSprite<{ score: number }>({\n  render({ props }) {\n    return [\n      MyWidget(\n        {\n          id: "MyWidget",\n          score: props.score,\n        },\n        (thisProps) => {\n          thisProps.score = props.score;\n        }\n      ),\n    ];\n  },\n});\n')))))}u.isMDXComponent=!0},159:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return m}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=r.a.createContext({}),c=function(e){var t=r.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},b=function(e){var t=c(e.components);return r.a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),b=c(n),d=a,m=b["".concat(l,".").concat(d)]||b[d]||u[d]||i;return n?r.a.createElement(m,p(p({ref:t},s),{},{components:n})):r.a.createElement(m,p({ref:t},s))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=d;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p.mdxType="string"==typeof e?e:a,l[1]=p;for(var s=2;s<i;s++)l[s]=n[s];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},167:function(e,t,n){"use strict";var a=n(0),r=n.n(a),i=n(176),l=n(169),p=n(57),o=n.n(p),s=37,c=39;t.a=function(e){var t=e.lazy,n=e.block,p=e.defaultValue,b=e.values,u=e.groupId,d=e.className,m=Object(i.a)(),h=m.tabGroupChoices,O=m.setTabGroupChoices,j=Object(a.useState)(p),y=j[0],f=j[1],g=a.Children.toArray(e.children);if(null!=u){var N=h[u];null!=N&&N!==y&&b.some((function(e){return e.value===N}))&&f(N)}var x=function(e){f(e),null!=u&&O(u,e)},S=[];return r.a.createElement("div",null,r.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(l.a)("tabs",{"tabs--block":n},d)},b.map((function(e){var t=e.value,n=e.label;return r.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":y===t,className:Object(l.a)("tabs__item",o.a.tabItem,{"tabs__item--active":y===t}),key:t,ref:function(e){return S.push(e)},onKeyDown:function(e){!function(e,t,n){switch(n.keyCode){case c:!function(e,t){var n=e.indexOf(t)+1;e[n]?e[n].focus():e[0].focus()}(e,t);break;case s:!function(e,t){var n=e.indexOf(t)-1;e[n]?e[n].focus():e[e.length-1].focus()}(e,t)}}(S,e.target,e)},onFocus:function(){return x(t)},onClick:function(){x(t)}},n)}))),t?Object(a.cloneElement)(g.filter((function(e){return e.props.value===y}))[0],{className:"margin-vert--md"}):r.a.createElement("div",{className:"margin-vert--md"},g.map((function(e,t){return Object(a.cloneElement)(e,{key:t,hidden:e.props.value!==y})}))))}},168:function(e,t,n){"use strict";var a=n(0),r=n.n(a);t.a=function(e){var t=e.children,n=e.hidden,a=e.className;return r.a.createElement("div",{role:"tabpanel",hidden:n,className:a},t)}},169:function(e,t,n){"use strict";function a(e){var t,n,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(r&&(r+=" "),r+=n);else for(t in e)e[t]&&(r&&(r+=" "),r+=t);return r}t.a=function(){for(var e,t,n=0,r="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(r&&(r+=" "),r+=t);return r}},176:function(e,t,n){"use strict";var a=n(0),r=n(178);t.a=function(){var e=Object(a.useContext)(r.a);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},178:function(e,t,n){"use strict";var a=n(0),r=Object(a.createContext)(void 0);t.a=r}}]);