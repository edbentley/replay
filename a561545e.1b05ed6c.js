(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{106:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return p})),n.d(t,"rightToc",(function(){return b})),n.d(t,"default",(function(){return d}));var a=n(2),r=n(6),i=(n(0),n(141)),o=n(148),l=n(149),c={id:"sprites",title:"Sprites"},p={unversionedId:"sprites",id:"sprites",isDocsHomePage:!1,title:"Sprites",description:"Replay is all about Sprites. Sprites are similar to Components in React.",source:"@site/docs/sprites.md",permalink:"/docs/sprites",editUrl:"https://github.com/edbentley/replay/edit/master/website/docs/sprites.md",sidebar:"someSidebar",previous:{title:"Replay Starter",permalink:"/docs/starter"},next:{title:"Textures",permalink:"/docs/textures"}},b=[{value:"Custom Sprite",id:"custom-sprite",children:[]},{value:"Stateful Sprite",id:"stateful-sprite",children:[]},{value:"Anchor Point",id:"anchor-point",children:[]},{value:"Common Props",id:"common-props",children:[]},{value:"Sprite Methods",id:"sprite-methods",children:[{value:"Common Parameters",id:"common-parameters",children:[]},{value:"<code>init</code>",id:"init",children:[]},{value:"<code>loop</code>",id:"loop",children:[]},{value:"<code>render</code>",id:"render",children:[]},{value:"<code>renderP</code>",id:"renderp",children:[]},{value:"<code>renderXL</code>",id:"renderxl",children:[]},{value:"<code>renderPXL</code>",id:"renderpxl",children:[]}]}],s={rightToc:b};function d(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Replay is all about Sprites. Sprites are similar to Components in React."),Object(i.b)("h2",{id:"custom-sprite"},"Custom Sprite"),Object(i.b)("p",null,"You can create a ",Object(i.b)("em",{parentName:"p"},"custom")," Sprite by passing an object into the ",Object(i.b)("inlineCode",{parentName:"p"},"makeSprite")," function:"),Object(i.b)(o.a,{defaultValue:"js",groupId:"code",values:[{label:"JavaScript",value:"js"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"js",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),'import { t, makeSprite } from "@replay/core";\n\nexport const Player = makeSprite({\n  render({ props }) {\n    return [\n      t.circle({\n        radius: 10,\n        color: props.color,\n      }),\n    ];\n  },\n});\n'))),Object(i.b)(l.a,{value:"ts",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { t, makeSprite } from "@replay/core";\n\ntype Props = {\n  color: string;\n};\nexport const Player = makeSprite<Props>({\n  render({ props }) {\n    return [\n      t.circle({\n        radius: 10,\n        color: props.color,\n      }),\n    ];\n  },\n});\n')))),Object(i.b)("p",null,"The Sprite object passed into ",Object(i.b)("inlineCode",{parentName:"p"},"makeSprite")," must have a method called ",Object(i.b)("inlineCode",{parentName:"p"},"render"),". The return value of ",Object(i.b)("inlineCode",{parentName:"p"},"render")," - an array of Sprites - is what Replay will draw onto the screen. Here we're drawing a circle with the colour set in its ",Object(i.b)("inlineCode",{parentName:"p"},"props"),"."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"props")," are values other Sprites can pass into the Sprite - just like arguments of a function. They're ",Object(i.b)("strong",{parentName:"p"},"read-only")," and should not be mutated."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"t")," is used to generate a ",Object(i.b)("em",{parentName:"p"},"Texture"),", which is a type of Sprite. The ",Object(i.b)("inlineCode",{parentName:"p"},"t.circle")," Texture accepts two ",Object(i.b)("inlineCode",{parentName:"p"},"props"),": ",Object(i.b)("inlineCode",{parentName:"p"},"radius")," and ",Object(i.b)("inlineCode",{parentName:"p"},"color"),". We'll cover them in more detail in ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/textures"}),"Textures")," next."),Object(i.b)("p",null,"Although not required, it's convention to capitalise custom Sprite names (",Object(i.b)("inlineCode",{parentName:"p"},"Player"),", not ",Object(i.b)("inlineCode",{parentName:"p"},"player"),")."),Object(i.b)("h2",{id:"stateful-sprite"},"Stateful Sprite"),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"Player")," Sprite is a pure function of ",Object(i.b)("inlineCode",{parentName:"p"},"props"),". But we can create an interactive Sprite by adding ",Object(i.b)("inlineCode",{parentName:"p"},"state"),":"),Object(i.b)(o.a,{defaultValue:"js",groupId:"code",values:[{label:"JavaScript",value:"js"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"js",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),'import { makeSprite } from "@replay/core";\nimport { Player } from "./player";\n\nexport const Level = makeSprite({\n  init() {\n    return { playerX: 0 };\n  },\n\n  loop({ state }) {\n    return {\n      playerX: state.playerX + 1,\n    };\n  },\n\n  render({ state }) {\n    return [\n      Player({\n        id: "player",\n        x: state.playerX,\n        rotation: 10,\n        color: "red",\n      }),\n    ];\n  },\n});\n\n'))),Object(i.b)(l.a,{value:"ts",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { makeSprite } from "@replay/core";\nimport { WebInputs } from "@replay/web";\nimport { iOSInputs } from "@replay/swift";\nimport { Player } from "./player";\n\ntype Props = {};\ntype State = {\n  playerX: number;\n};\n\nexport const Level = makeSprite<Props, State, WebInputs | iOSInputs>({\n  init() {\n    return { playerX: 0 };\n  },\n\n  loop({ state }) {\n    return {\n      playerX: state.playerX + 1,\n    };\n  },\n\n  render({ state }) {\n    return [\n      Player({\n        id: "player",\n        x: state.playerX,\n        rotation: 10,\n        color: "red",\n      }),\n    ];\n  },\n});\n')))),Object(i.b)("p",null,"This ",Object(i.b)("inlineCode",{parentName:"p"},"Level")," Sprite has an ",Object(i.b)("inlineCode",{parentName:"p"},"init")," method which returns the initial state - a value ",Object(i.b)("inlineCode",{parentName:"p"},"playerX")," for the player's ",Object(i.b)("inlineCode",{parentName:"p"},"x")," position."),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"loop")," method takes the current ",Object(i.b)("inlineCode",{parentName:"p"},"state")," and returns a new value for ",Object(i.b)("inlineCode",{parentName:"p"},"state"),". This is where we can write our game logic for interactive things (in this case we're increasing the player's ",Object(i.b)("inlineCode",{parentName:"p"},"x")," position). ",Object(i.b)("inlineCode",{parentName:"p"},"loop")," is called by Replay 60 times a second (we'll cover this more in ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/game-loop"}),"Game Loop"),")."),Object(i.b)("p",null,"Just like ",Object(i.b)("inlineCode",{parentName:"p"},"props"),", ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"state")," is also read-only"),". You should always return a new value of ",Object(i.b)("inlineCode",{parentName:"p"},"state")," and not mutate it, ensuring the ",Object(i.b)("inlineCode",{parentName:"p"},"loop")," method remains pure."),Object(i.b)("p",null,"Lastly our ",Object(i.b)("inlineCode",{parentName:"p"},"render")," method takes our existing ",Object(i.b)("inlineCode",{parentName:"p"},"state")," and returns the ",Object(i.b)("inlineCode",{parentName:"p"},"Player")," Sprite:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),'  render({ state }) {\n    return [\n      Player({\n        id: "player",\n        x: state.playerX,\n        rotation: 10,\n        color: "red",\n      }),\n    ];\n  },\n')),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Player")," (which we created above using ",Object(i.b)("inlineCode",{parentName:"p"},"makeSprite"),") is just a function we can call with its ",Object(i.b)("inlineCode",{parentName:"p"},"props"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"id"),": Every custom Sprite (not Textures) requires an ",Object(i.b)("inlineCode",{parentName:"li"},"id")," prop, which is a string of any value you want. The ",Object(i.b)("inlineCode",{parentName:"li"},"id")," ",Object(i.b)("strong",{parentName:"li"},"must be unique within a single render function"),", but doesn't need to be unique globally. The unique ",Object(i.b)("inlineCode",{parentName:"li"},"id")," is how Replay tracks the ",Object(i.b)("inlineCode",{parentName:"li"},"state")," of different Sprites."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"x"),": Every Sprite (including Textures) has an optional ",Object(i.b)("inlineCode",{parentName:"li"},"x")," and ",Object(i.b)("inlineCode",{parentName:"li"},"y")," prop to set its position."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"rotation"),": Like the ",Object(i.b)("inlineCode",{parentName:"li"},"x")," prop, you can set the Sprite's rotation in degrees."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"color"),": This is the prop defined in the ",Object(i.b)("inlineCode",{parentName:"li"},"Player")," Sprite itself.")),Object(i.b)("h2",{id:"anchor-point"},"Anchor Point"),Object(i.b)("p",null,"When Sprites are positioned, the position is relative the ",Object(i.b)("em",{parentName:"p"},"anchor point"),", which is in the middle of the Sprite. You can then adjust this anchor point using the ",Object(i.b)("inlineCode",{parentName:"p"},"anchorX")," and ",Object(i.b)("inlineCode",{parentName:"p"},"anchorY")," props (see ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#common-props"}),"Common Props")," below). ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/game-size"}),"Game Size")," covers the coordinate system in more detail."),Object(i.b)("img",{src:"/img/anchor-point.png",width:"50%"}),Object(i.b)("h2",{id:"common-props"},"Common Props"),Object(i.b)("p",null,"All Sprites can be given the following props:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"id"),": (Required) Identifier, must be unique within a single render function."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"x"),": x coordinate of Sprite. Default ",Object(i.b)("inlineCode",{parentName:"li"},"0"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"y"),": y coordinate of Sprite. Default ",Object(i.b)("inlineCode",{parentName:"li"},"0"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"rotation"),": Rotation of Sprite around anchor point in degrees (clockwise). Default ",Object(i.b)("inlineCode",{parentName:"li"},"0"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"opacity"),": A number between 0 and 1. Default ",Object(i.b)("inlineCode",{parentName:"li"},"1"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"scaleX"),": Scale the Texture horizontally around the anchor point. Default ",Object(i.b)("inlineCode",{parentName:"li"},"1"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"scaleY"),": Scale the Texture vertically around the anchor point. Default ",Object(i.b)("inlineCode",{parentName:"li"},"1"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"anchorX"),": Move the ",Object(i.b)("inlineCode",{parentName:"li"},"x")," anchor point in game coordinates from the center point of the Sprite. Default ",Object(i.b)("inlineCode",{parentName:"li"},"0"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"anchorY"),": Move the ",Object(i.b)("inlineCode",{parentName:"li"},"y")," anchor point in game coordinates from the center point of the Sprite. Default ",Object(i.b)("inlineCode",{parentName:"li"},"0"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"mask"),": Apply a mask to the Sprite's content, see ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"/docs/mask"}),"Mask")," for the shapes possible. Default ",Object(i.b)("inlineCode",{parentName:"li"},"null"),".")),Object(i.b)("p",null,"Here's how you could combine ",Object(i.b)("inlineCode",{parentName:"p"},"anchorX")," and ",Object(i.b)("inlineCode",{parentName:"p"},"scaleX")," for a health bar effect:"),Object(i.b)("p",null,Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"/img/anchor-scale.png",alt:"anchorX and scaleX usage for health bar"}))),Object(i.b)("h2",{id:"sprite-methods"},"Sprite Methods"),Object(i.b)("p",null,"Sprite methods are the fields of the object you pass into ",Object(i.b)("inlineCode",{parentName:"p"},"makeSprite"),". ",Object(i.b)("inlineCode",{parentName:"p"},"render")," is the only ",Object(i.b)("em",{parentName:"p"},"required")," Sprite method. ",Object(i.b)("inlineCode",{parentName:"p"},"init")," is required if your Sprite has ",Object(i.b)("inlineCode",{parentName:"p"},"state"),"."),Object(i.b)("h3",{id:"common-parameters"},"Common Parameters"),Object(i.b)("p",null,"All Sprite methods have the following parameters:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"props"),": The props passed in by the parent Sprite."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"device"),": The device object, see ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"/docs/device"}),"Device"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"updateState"),": A callback to update the ",Object(i.b)("inlineCode",{parentName:"li"},"state")," of the Sprite. Useful for asynchronous things like timers. Pass a function which takes the existing state and returns a new state. E.g:",Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"updateState((prevState) => ({ ...prevState, playerX: 0 }));\n")))),Object(i.b)("h3",{id:"init"},Object(i.b)("inlineCode",{parentName:"h3"},"init")),Object(i.b)("p",null,"Called on initial load of Sprite. Use this to run anything you need on setup. Returns the initial state."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"  init({ props, device, updateState, preloadFiles, getState }) {\n    return { ... };\n  },\n")),Object(i.b)("h4",{id:"additional-parameters"},"Additional Parameters"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"preloadFiles(assets)"),": An async function which loads assets (like images and audio files) for this Sprite. The files will be cleared from memory when the Sprite is unmounted. Since it returns a promise you can chain ",Object(i.b)("inlineCode",{parentName:"li"},".then")," to know when the files have finished loading.",Object(i.b)("pre",{parentName:"li"},Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),'preloadFiles({\n imageFileNames: ["enemy.png"],\n audioFileNames: ["shoot.wav"],\n}).then(() => {\n updateState((state) => ({ ...state, loaded: true }));\n});\n'))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"getState"),": A function which returns the current state of the Sprite for asynchronous callbacks. If you call this before ",Object(i.b)("inlineCode",{parentName:"li"},"init")," returns it will throw an error.")),Object(i.b)("h3",{id:"loop"},Object(i.b)("inlineCode",{parentName:"h3"},"loop")),Object(i.b)("p",null,"Called every frame of the game. Put your game logic here. Returns the next frame's state."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"  loop({ props, state, device, updateState }) {\n    return { ...state, ... };\n  },\n")),Object(i.b)("h4",{id:"additional-parameters-1"},"Additional Parameters"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"state"),": The current state of the Sprite.")),Object(i.b)("h3",{id:"render"},Object(i.b)("inlineCode",{parentName:"h3"},"render")),Object(i.b)("p",null,"Called when the device renders to screen. Returns an array of Sprites to render."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"  render({ props, state, device, updateState, extrapolateFactor }) {\n    return [ ... ];\n  },\n")),Object(i.b)("h4",{id:"additional-parameters-2"},"Additional Parameters"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"state"),": The current state of the Sprite."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"extrapolateFactor"),": A value between 0 and 1 representing how much time has passed before the next frame is scheduled. See ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"/docs/game-loop"}),"Game Loop")," for more.")),Object(i.b)("h3",{id:"renderp"},Object(i.b)("inlineCode",{parentName:"h3"},"renderP")),Object(i.b)("p",null,"An alternative render method run if the device is in portrait. See ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/game-size"}),"Game Size")," for more."),Object(i.b)("h3",{id:"renderxl"},Object(i.b)("inlineCode",{parentName:"h3"},"renderXL")),Object(i.b)("p",null,"An alternative render method run for large screens. See ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/game-size"}),"Game Size")," for more."),Object(i.b)("h3",{id:"renderpxl"},Object(i.b)("inlineCode",{parentName:"h3"},"renderPXL")),Object(i.b)("p",null,"An alternative render method run for large screens if the device is in portrait. See ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/game-size"}),"Game Size")," for more."))}d.isMDXComponent=!0},141:function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return m}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=r.a.createContext({}),b=function(e){var t=r.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=b(e.components);return r.a.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),s=b(n),u=a,m=s["".concat(o,".").concat(u)]||s[u]||d[u]||i;return n?r.a.createElement(m,l(l({ref:t},p),{},{components:n})):r.a.createElement(m,l({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},148:function(e,t,n){"use strict";var a=n(0),r=n.n(a),i=n(157),o=n(154),l=n(49),c=n.n(l),p=37,b=39;t.a=function(e){var t=e.block,n=e.children,l=e.defaultValue,s=e.values,d=e.groupId,u=Object(i.a)(),m=u.tabGroupChoices,j=u.setTabGroupChoices,O=Object(a.useState)(l),h=O[0],f=O[1],N=Object(a.useState)(!1),y=N[0],C=N[1];if(null!=d){var v=m[d];null!=v&&v!==h&&s.some((function(e){return e.value===v}))&&f(v)}var g=function(e){f(e),null!=d&&j(d,e)},S=[],w=function(e){e.metaKey||e.altKey||e.ctrlKey||C(!0)},x=function(){C(!1)};return Object(a.useEffect)((function(){window.addEventListener("keydown",w),window.addEventListener("mousedown",x)}),[]),r.a.createElement("div",null,r.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(o.a)("tabs",{"tabs--block":t})},s.map((function(e){var t=e.value,n=e.label;return r.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":h===t,className:Object(o.a)("tabs__item",c.a.tabItem,{"tabs__item--active":h===t}),style:y?{}:{outline:"none"},key:t,ref:function(e){return S.push(e)},onKeyDown:function(e){!function(e,t,n){switch(n.keyCode){case b:!function(e,t){var n=e.indexOf(t)+1;e[n]?e[n].focus():e[0].focus()}(e,t);break;case p:!function(e,t){var n=e.indexOf(t)-1;e[n]?e[n].focus():e[e.length-1].focus()}(e,t)}}(S,e.target,e),w(e)},onFocus:function(){return g(t)},onClick:function(){g(t),C(!1)},onPointerDown:function(){return C(!1)}},n)}))),r.a.createElement("div",{role:"tabpanel",className:"margin-vert--md"},a.Children.toArray(n).filter((function(e){return e.props.value===h}))[0]))}},149:function(e,t,n){"use strict";var a=n(0),r=n.n(a);t.a=function(e){return r.a.createElement("div",null,e.children)}},154:function(e,t,n){"use strict";function a(e){var t,n,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(r&&(r+=" "),r+=n);else for(t in e)e[t]&&(r&&(r+=" "),r+=t);return r}t.a=function(){for(var e,t,n=0,r="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(r&&(r+=" "),r+=t);return r}},157:function(e,t,n){"use strict";var a=n(0),r=n(159);t.a=function(){var e=Object(a.useContext)(r.a);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},159:function(e,t,n){"use strict";var a=n(0),r=Object(a.createContext)(void 0);t.a=r}}]);